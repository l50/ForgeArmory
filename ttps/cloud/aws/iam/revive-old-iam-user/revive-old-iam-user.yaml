---
name: revive-old-iam-user
description: Add an access key to a previously dormant IAM user.
args:
  - name: detect
    default: true
  - name: user
mitre:
  tactics:
    - TA0003 Persistence
  techniques:
    - T1098 Account Manipulation

steps:
  - name: ensure_aws_creds_present
    inline: |
      set -e

      if [[ -z "${AWS_DEFAULT_REGION}" ]]; then
          echo "Error: AWS_DEFAULT_REGION must be set."
          exit 1
      fi
      if [[ -n "${AWS_ACCESS_KEY_ID}" && -n "${AWS_SECRET_ACCESS_KEY}" ]]; then
          if [[ -z "${AWS_SESSION_TOKEN}" ]]; then
            echo "Warning: AWS_SESSION_TOKEN is not set with AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY."
          fi
      elif [[ -z "${AWS_PROFILE}" ]]; then
          echo "Error: AWS credentials are not set, exiting."
          exit 1
      fi

  - name: ensure_aws_cli_present
    inline: |
      set -e

      if ! [ -x "$(command -v aws)" ]; then
        echo 'Error: AWS CLI is not installed.' >&2
      else
        echo -e "AWS CLI is installed: $(aws --version)"
      fi

  - name: add_access_key
    inline: |
      set -e

      function create_key() {
        local user=$1

        # Create a new key
        new_key=$(aws iam create-access-key --user-name $user)

        # Extract new access key id
        new_access_key_id=$(echo $new_key | jq -r '.AccessKey.AccessKeyId')

        # Store the new list of keys
        keys_after=$(aws iam list-access-keys --user-name $user --query 'AccessKeyMetadata[].AccessKeyId' --output text)

        # Confirm that a new key has been added
        if [[ "$keys_after" == *"$new_access_key_id"* ]]; then
          echo $new_access_key_id
        else
          echo "Failed to add new key for $user"
          exit 1
        fi
      }

      new_access_key=$(create_key {{ .Args.user }})
      # Output value to pick up output in the cleanup step
      echo "$new_access_key"

    cleanup:
      name: cleanup
      inline: |
        set -e

        function delete_key() {
          local user=$1
          local new_access_key_id=$2

          # Ensure a user and new_access_key_id are provided
          if [[ -z "$user" ]] || [[ -z "$new_access_key_id" ]]; then
              if [[ -z "$user" ]]; then
                  echo "Error: User must be provided."
              fi
              if [[ -z "$new_access_key_id" ]]; then
                  echo "Error: Access key ID must be provided."
              fi
              exit 1
          fi

          aws iam delete-access-key --access-key-id $new_access_key_id --user-name $user

          # Confirm that the key has been deleted
          keys_final=$(aws iam list-access-keys --user-name $user --query 'AccessKeyMetadata[].AccessKeyId' --output text)

          if [[ "$keys_final" != *"$new_access_key_id"* ]]; then
            echo "Key $new_access_key_id has been deleted for $user"
          else
            echo "Failed to delete key for $user"
            exit 1
          fi
        }

        delete_key "{{ .Args.user }}" $forge.steps.add_access_key.stdout

  - name: check_detection
    inline: |
      set -e

      if [ "{{ .Args.detect }}" == true ]; then
        current_time() {
            date -u +'%Y-%m-%dT%H:%M:%SZ'
        }

        ten_minutes_ago() {
            if [[ "$OSTYPE" == "darwin"* ]]; then
                date -v-10M -u +'%Y-%m-%dT%H:%M:%SZ'
            else
                date -u -d '10 minutes ago' +'%Y-%m-%dT%H:%M:%SZ'
            fi
        }

        # Define a time window for CloudTrail lookup
        START_TIME=$(ten_minutes_ago)
        END_TIME=$(current_time)

        # Check for `CreateAccessKey` and `GenerateDataKey` events in the last 10 minutes
        EVENT_NAMES=("CreateAccessKey" "GenerateDataKey")

        for event_name in "${EVENT_NAMES[@]}"; do
            EVENTS=$(aws cloudtrail lookup-events \
                --lookup-attributes AttributeKey=EventName,AttributeValue=$event_name \
                --start-time $START_TIME \
                --end-time $END_TIME \
                --region us-east-1)

            EVENT_COUNT=$(echo "$EVENTS" | jq -r '.Events | length')

            if [[ "$EVENT_COUNT" -gt 0 ]]; then
                echo "Detected $EVENT_COUNT recent $event_name events."
            else
                echo "No recent $event_name events detected."
            fi
        done
      fi
